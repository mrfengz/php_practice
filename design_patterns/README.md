## PHP设计模式
    为什么采用面向对象编程
        1. 解决问题更容易。将大问题分解为小问题。
        2. 模块化。
        3. 加快开发和修改速度。
        
## 相关概念
    1. 类与对象
    
        类：属性和方法
    
    2. 单一职责
    
    3. 签名
        
        操作名(参数)--> 签名
    
    3. 抽象： 接口和抽象类
        
        抽象：指示一个对象的基本特征，与其他对象进行区分，从查看者的角度提供了清晰定义的概念边界
        
        抽象类： 
            1. 不能实例化
            2. 必须由具体类继承抽象类的接口
            3. 可以包含具体方法
            4. 可以包含属性
            
        接口：
            1. 不能包含属性，但可以包含常量
            2. 不能包含具体的方法(只有签名，无具体实现)

        * 类型提示：   一般使用接口(接口和抽象类) 作为类型提示。
        
    4. 特性
        1. 封装
            可见性控制
        2. 继承
            使用继承来获取某个类的属性和方法，同时可以进行自己的扩展。
        3. 多态
            多种形态。调用有相同接口的对象，完成不同的工作。
            比如动物鸣叫的方法，dog类实现为'汪汪',猫为'喵喵'。    
    
    5. MVC
        视图--控制器--模型
        
        展示了松耦合，分离不同的元素来完成一个任务，提供了更大的灵活性。

## 设计模式的原则

    1. 按接口而不是按照实现来编程。
        将变量设置为一个抽象类或者接口数据类型的实例，而不是一个具体实现的实例。
       代码提示中使用接口(即签名)数据类型(只要实现了该接口，其输出都可以预测)            
    2. 应当优先选择组合而不是类继承。                           
        继承： IS-A
        组合：HAS-A
        
        使用浅继承，避免修改父类影响到所有多层级的子类，导致未预期的错误。
        使用委托(组合)可以有助于避免紧密绑定

## 设计模式组织分类
   
    1. 创建型
        创建对象的模式。提供一些方法封装系统使用的具体类的有关知识，还可以隐藏实例创建和组合的相关信息。
    2. 结构型
        组合结构应当保证结构化。通过继承、组合对象建立新功能
    3. 行为型             
        核心是算法和对象之间的职责分配。  
    4. 类模式
        重点在于类和子类之间的关系。通过继承建立，是静态的，编译时已经固定。
    5. 对象模式
        对象模式强调的是可以在运行时可以改变的对象，更具有动态性。
        
    * 设计模式是编程中反复出现的常见问题的解决方案，但是也不是一成不变的。
    * 选择世界模式时需要考虑什么导致了重新设计？什么会变化(重点转化为封装那些变化的概念)？   
    
## 创建型设计模式
    1. 抽象工厂
    2. 生成器
    3. 工厂方法
        client并不直接实例化请求的产品，而是由工厂负责实例化请求的产品。
        使用场景：一个类无法预计它要创建的对象数目。
    4. 原型
        实现：通过复制原型实例创建新对象。
        作用：原型设计模式通过使用克隆减少实例化对象的开销
    5. 单例  
    
## 结构型设计模式
    结构性设计模式主要研究的是如何组合对象和类，来构成更大的结构。

    1. 适配器模式(Adapter)
        组合优于继承。参与者之间绑定更宽松，在重用、结构、修改等方面有很多优点。
        就像要给手机充电一样，必须用usb数据线，将电脑或者插座插槽适配成为适合手机的端口。(功能一样，形式不同)
        示例：网站--手机/PC端布局. 货币兑换
        
        UML图:
        ![部门原型](https://github.com/mrfengz/php_practice/blob/master/design_patterns/structure/adapter.jpg)

    2. 桥接模式(Bridge)
    3. 组合模式(Composite)
    4. 装饰器模式(Decorator)
        为一个已有的结构增加“装饰”,而不影响其它其它对象。
        适配器：为现有结构增加一个适配器类，用来处理不兼容的接口。
        装饰器：向现有对象增加对象。抽象类(装饰器Decorator)继承另一个抽象类(Component)
        Component想成是空房间，地毯和家具看成是具体的装饰器。
        
        UML图：
        ![装饰器类图](https://github.com/mrfengz/php_practice/blob/master/design_patterns/structure/decorator_1.png)

    5. 外观模式(Pacade)
    6. 享元模式(Flyweight)
    7. 代理模式(Proxy)
    
 ## 行为型设计模式
    行为型设计模式的关键是通信。对于这些模式，重点不再是构成一个设计模式的对象和类，而蝇转变成对象和类之间的对象。最好考虑对象如何相互合作来完成任务。
    
    职责连模式(Chain of Responsibility)
    命令模式(Command) 
    解释器模式(Interpreter)
    迭代器模式(Iterator)
    中介者模式(Mediator)
    备忘录模式(Memento)
    观察者模式(Observer)
    状态模式(State)
    策略模式(Strategy)
    模板方法模式(Template Method)
        使用了一个类方法templateMethod()，是一个抽象类的具体方法，这个方法的具体作用是对抽象方法序列排序。但具体实现留给具体类来完成。定义了操作中算法的“骨架”。
        类似与婚礼司仪的程序，但是具体形式可以由自己商量
        
        使用场景：已经明确算法的一些步骤，不过这些步骤可以采用多种不同的方法实现，就可以使用模板方法。
    访问者模式 (Visitor)
    
> 反向控制原则：父类调用子类的操作，而子类不调用父类的操作。